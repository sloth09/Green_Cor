GREEN CORRIDOR CODEBASE - NON-UNIFIED CALCULATION ANALYSIS
===========================================================

EXECUTIVE SUMMARY
-----------------
Found 8 critical areas where the same calculations are performed in multiple files 
with DIFFERENT implementations. These can cause discrepancies between optimizer.py, 
main.py, and cost calculations.

DETAILED FINDINGS
=================

1. PUMP FUEL COST CALCULATION - CRITICAL DISCREPANCY
======================================================
   STATUS: BROKEN - Has 2.0 factor in one place, not in others
   SEVERITY: HIGH
   
   Location 1 - src/cost_calculator.py (Line 214):
   ---------
   pumping_time_hr = 2.0 * (bunker_volume_m3 / pump_flow_m3ph)
   
   Location 2 - src/optimizer.py (Line 204):
   ---------
   pumping_time_hr_call = self.bunker_volume_per_call_m3 / pump_size
   [NO 2.0 factor]
   
   Location 3 - main.py (Line 390):
   ---------
   pumping_time_hr_call = bunker_volume / pump_size_m3ph
   [NO 2.0 factor]
   
   ISSUE: 
   - cost_calculator.py calculates pumping time WITH 2.0 factor
   - optimizer.py and main.py calculate it WITHOUT 2.0 factor
   - This means cost_calculator is calculating pump fuel costs DOUBLE what 
     optimizer and main.py expect
   - The CLAUDE.md mentions this was fixed in v2.3.1, but cost_calculator.py 
     still has the erroneous 2.0 factor
   
   IMPACT: Pump fuel costs are inconsistent - CostCalculator thinks pumping 
   takes twice as long as optimizer/main.py think
   
   EXAMPLE:
   bunker_volume = 5000 m³, pump_size = 1000 m³/h
   - CostCalculator: 2.0 * (5000 / 1000) = 10.0 hours
   - Optimizer/Main: 5000 / 1000 = 5.0 hours
   - Cost difference: 2x over estimated


2. TOTAL SUPPLY CALCULATION (20-YEAR) - CASE 1 VS CASE 2 INCONSISTENCY
========================================================================
   SEVERITY: HIGH
   
   Location - src/optimizer.py (Lines 376-383):
   --------
   total_supply_m3 = 0.0
   for t in self.years:
       y_val = y[t].varValue
       if self.has_storage_at_busan:
           total_supply_m3 += y_val * self.bunker_volume_per_call_m3  [CORRECT]
       else:
           total_supply_m3 += y_val * shuttle_size                     [QUESTIONABLE]
   
   ISSUE:
   - Case 1: y[t] = annual calls, so y[t] * bunker_volume = total m³ supplied ✓
   - Case 2: y[t] = annual calls (number of vessel calls), but uses shuttle_size
   - In Case 2, if 10,000 m³ shuttle serves 2 vessels (5,000 each):
     * There are 2 vessel calls per shuttle trip
     * y[t] counts vessel calls, not shuttle trips
     * Using shuttle_size instead of bunker_volume_per_call_m3 double-counts supply
   
   EXPECTED: Case 2 should also use bunker_volume_per_call_m3 for consistency
   
   IMPACT: Case 2 LCOAmmonia ($/ton) will be UNDERSTATED
   - Total supply appears inflated
   - Cost per unit appears lower than actual


3. ANNUAL SUPPLY CALCULATION (THEORETICAL MAX) - NOT MATCHED TO ACTUAL
=======================================================================
   SEVERITY: MEDIUM
   
   Location 1 - src/cycle_time_calculator.py (Line 120):
   ----------
   annual_supply_m3 = annual_cycles * shuttle_size_m3
   [Calculated from max annual cycles: 8000 / cycle_duration]
   
   Location 2 - src/optimizer.py (Line 404):
   ----------
   annual_supply_m3 = annual_cycles_max * shuttle_size
   [Same calculation]
   
   Location 3 - src/optimizer.py (Line 431):
   ----------
   "Ships_Per_Year": round(annual_supply_m3 / self.bunker_volume_per_call_m3, 2)
   [Uses theoretical max, not actual optimization result]
   
   ISSUE:
   - annual_supply_m3 is theoretical max capacity
   - But Ships_Per_Year divides this by bunker_volume
   - This doesn't account for whether optimizer actually uses this capacity
   - In yearly results, "Supply_m3" is calculated differently:
       supply = y_val * self.bunker_volume_per_call_m3
   - Mismatch: scenario-level annual_supply_m3 vs yearly-level supply calculation
   
   EXPECTED: Ships_Per_Year should be calculated from actual y[t] values, not theoretical max
   
   IMPACT: Ships_Per_Year metric overstates actual capacity utilization


4. DEMAND SATISFACTION CONSTRAINT - DIFFERENT LOGIC FOR CASE 1 VS CASE 2
=========================================================================
   SEVERITY: MEDIUM
   
   Location - src/optimizer.py (Lines 274-277):
   --------
   if self.has_storage_at_busan:  # Case 1
       prob += y[t] * self.bunker_volume_per_call_m3 >= self.annual_demand[t]
   else:  # Case 2
       prob += y[t] * shuttle_size >= self.annual_demand[t]
   
   ISSUE:
   - Case 1: y[t] represents vessel calls (each call = bunker_volume) ✓
   - Case 2: y[t] ALSO represents vessel calls, not shuttle trips
   - But constraint uses shuttle_size instead of bunker_volume
   - This treats y[t] as if it represents shuttle trips in Case 2
   
   INCONSISTENCY:
   In working time constraint (Line 280):
       prob += y[t] * trips_per_call * cycle_duration <= N[t] * self.max_annual_hours
   - This treats y[t] as annual calls for BOTH cases
   - But demand constraint treats it as shuttle trips for Case 2
   
   IMPACT: Demand constraint is incorrectly specified for Case 2
   - Optimizer thinks y[t] is "trips" in demand constraint
   - But y[t] is actually "calls" throughout rest of code
   

5. ANNUITY FACTOR CALCULATION - HARDCODED 20 YEARS
====================================================
   SEVERITY: LOW (but potential for error)
   
   Location 1 - src/cost_calculator.py (Line 381):
   ----------
   project_years = 20  # Fixed: 2030-2050
   return calculate_annuity_factor(discount_rate, project_years)
   
   Location 2 - src/optimizer.py (implicit):
   ----------
   Assumes 20 years via cycle: self.years = range(2030, 2050+1) = 21 years
   
   ISSUE:
   - cost_calculator.py hardcodes project_years = 20
   - optimizer.py calculates years as range(start_year, end_year+1)
   - This is actually 21 years (2030 through 2050 inclusive)
   - Discrepancy: 20 vs 21 years for annuity calculation
   
   ACTUAL ISSUE: The code uses 2030-2050 range which is 21 elements, 
   but calculates annuity factor for 20 years. Small but systematic error.
   
   IMPACT: Annualized costs are slightly overstated (divide by smaller factor)


6. SHUTTLE FUEL COST CALCULATION - TRAVEL FACTOR NOT USED IN COST_CALCULATOR
==============================================================================
   SEVERITY: LOW
   
   Location 1 - src/optimizer.py (Line 195):
   ----------
   travel_factor = 1.0 if self.has_storage_at_busan else 2.0
   shuttle_fuel_per_cycle = (mcr * self.sfoc * travel_factor * self.travel_time_hours) / 1e6
   
   Location 2 - main.py (Line 374):
   ----------
   travel_factor = 1.0 if has_storage_at_busan else 2.0
   shuttle_fuel_per_cycle = (mcr * sfoc * travel_factor * travel_time_hours) / 1e6
   
   Location 3 - src/cost_calculator.py (Line 76-110):
   ----------
   def calculate_shuttle_fuel_cost_per_cycle(self, shuttle_size_cbm, travel_time_hours):
       # Does NOT use has_storage_at_busan flag
       # Always calculates as single one-way trip
       fuel_ton = (mcr * sfoc * travel_time_hours) / 1e6
   
   ISSUE:
   - Optimizer and main.py correctly use travel_factor (2.0 for Case 2 round-trip)
   - Cost_calculator.py doesn't take has_storage_at_busan as parameter
   - Can't adjust for Case 1 vs Case 2 differences
   - If cost_calculator.py is called directly, it will understate fuel costs for Case 2
   
   IMPACT: If cost_calculator.py is used standalone, Case 2 shuttle fuel costs 
   are understated by 50%


7. ANNUAL CYCLES CALCULATION - MULTIPLE DEFINITIONS
====================================================
   SEVERITY: MEDIUM
   
   Location 1 - src/cycle_time_calculator.py (Line 119):
   ----------
   annual_cycles = 8000.0 / cycle_duration if cycle_duration > 0 else 0
   
   Location 2 - src/optimizer.py (Line 403):
   ----------
   annual_cycles_max = 8000 / cycle_duration if cycle_duration > 0 else 0
   
   Location 3 - main.py (Line 330):
   ----------
   annual_cycles = total_trips
   [This is ACTUAL cycles from optimization, not max theoretical]
   
   Location 4 - main.py (Line 464):
   ----------
   annual_cycles_max = max_annual_hours / cycle_duration if cycle_duration > 0 else 0
   
   ISSUE:
   - "annual_cycles" has different meanings in different contexts
   - Cycle_time_calculator: theoretical max cycles
   - Optimizer scenario: theoretical max cycles  
   - Main annual_simulation: actual trips (not max)
   - Result: Annual_Cycles_Max in optimizer output ≠ actual annual_cycles in main.py
   
   IMPACT: Metrics are confusing - theoretical vs actual are mixed


8. FLEET SIZING CALCULATION - MULTIPLE IMPLEMENTATIONS
========================================================
   SEVERITY: MEDIUM
   
   Location 1 - main.py (Lines 314-316):
   ----------
   fleet_calc = FleetSizingCalculator(config)
   required_shuttles = fleet_calc.calculate_required_shuttles_working_time_only(
       annual_calls, trips_per_call, cycle_duration)
   
   Location 2 - src/optimizer.py (Line 290 - COMMENT only, not actual code):
   ----------
   #   required_shuttles = ceil((annual_calls × trips_per_call × cycle_duration) / max_annual_hours)
   [Uses working time constraint in MILP, implicit calculation]
   
   ISSUE:
   - main.py explicitly calls FleetSizingCalculator
   - optimizer.py doesn't directly calculate required_shuttles
   - Optimizer uses MILP constraints to implicitly size fleet
   - If constraint changes, fleet sizing changes, but main.py won't reflect it
   
   IMPACT: annual_simulation may use different fleet sizing than optimizer
   if MILP constraints are modified


SUMMARY BY PRIORITY
===================

CRITICAL (Must Fix):
- Issue 1: Pump fuel cost calculation (2.0 factor in cost_calculator.py)
- Issue 2: Total supply calculation for Case 2 (uses shuttle_size instead of bunker_volume)

HIGH (Should Fix):
- Issue 3: Annual supply vs actual supply mismatch
- Issue 4: Demand satisfaction constraint logic for Case 2

MEDIUM (Should Review):
- Issue 5: Annuity factor 20 vs 21 years
- Issue 7: Annual cycles definition inconsistency
- Issue 8: Fleet sizing implementation differences

LOW (Monitor):
- Issue 6: Shuttle fuel cost factor in cost_calculator.py

RECOMMENDATIONS
===============
1. Remove 2.0 factor from cost_calculator.py line 214
2. Change Case 2 supply calculation to use bunker_volume_per_call_m3
3. Calculate Ships_Per_Year from actual y[t] values, not theoretical max
4. Review demand satisfaction constraint for Case 2
5. Unify annuity factor calculation (20 vs 21 years issue)
6. Add has_storage_at_busan parameter to cost_calculator shuttle fuel calculation
7. Create unified annual cycles definitions across all files

